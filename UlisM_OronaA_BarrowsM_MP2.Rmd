---
title: "Untitled"
author: "Maeric Barrows"
date: "2024-04-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Front Matter
```{r loadPackages, message = FALSE, warning=FALSE}
#Load packages with groundhog to improve stability
library(tidyverse)
library(rvest)
library(ggplot2)
library(lubridate)
library(kableExtra)
```

## Read in Data Set/Data Wrangling - Michael

```{r}
COD1 <- read_html(
  x = "https://docs.google.com/spreadsheets/d/1Wv5dlzCYv37aY58MF9nuuYJbHRBWm_dQ/edit?usp=sharing&ouid=106338911046216482900&rtpof=true&sd=true"
) %>%
  html_elements(css = "table") %>%
  html_table()

COD1 <- COD1[[1]]

COD2 <- read_html(
  x = "https://docs.google.com/spreadsheets/d/1Ora5ZiTjb2qrmqPV6P1wh7CyJweHpw7NJ1kxXWVodfk/edit?usp=sharing"
) %>%
  html_elements(css = "table") %>%
  html_table()

COD2 <- COD2[[1]]

COD3 <- read_html(
  x = "https://docs.google.com/spreadsheets/d/1ZlUHg4408PpJlFJeXENcqujAI7LWRL0o8ElHciJNlEw/edit?usp=sharing"
) %>%
  html_elements(css = "table") %>%
  html_table()

COD3 <- COD3[[1]]

colnames(COD1) <- COD1[1,]

colnames(COD2) <- COD2[1,]

colnames(COD3) <- COD3[1,]

COD1 <- COD1[-1, ]

COD1 <- COD1[-1, ]

COD1 <- COD1[, -1]

COD2 <- COD2[-1, ]

COD2 <- COD2[, -1]

COD3 <- COD3[-1, ]

COD3 <- COD3[, -1]

COD3 <- COD3[-(14:99),]

COD <- full_join(COD1, COD2)

COD <- full_join(COD, COD3)

COD[COD == ""] <- NA

COD$Eliminations <- as.numeric(COD$Eliminations)

COD$Deaths <- as.numeric(COD$Deaths)

COD$Score <- as.numeric(COD$Score)

COD$TotalXP <- as.numeric(COD$TotalXP)

COD$Damage <- as.numeric(COD$Damage)

COD <- COD %>%
  separate(Result, c("YourScore", "OtherScore"))

glimpse(COD)
```

## 1. Why not na.omit()?
We would not want to use na.omit for this dataset because at least one instance of NA is present in every row. If we were to use na.omit, every single row would be removed from the table. The below function shows how many NAs are present in each row:

```{r}
countNA <- function(dat){
  numNA <- sum(is.na(dat))
  return(numNA)
}

# MARGIN = 1 allows this to countNA by row
apply(X = COD, MARGIN = 1, FUN = countNA)
```

## 2. 6 Visualizations (My 2)

### Damage - Ayla Orona

```{r}
sum(is.na(COD$Damage))
```
There is 0 missing Damage data in the table.

```{r}
COD %>%
  summarize(mean = mean(Damage),
            median = median(Damage),
            StandardD = sd(Damage),
            min = min(Damage),
            max = max(Damage))
```

The variable Damage is quantitative data, meaning its type of data is only integers. For the Damage column, the mean is 415.16, the median is 397, the standard deviation is 166.31, the min is 56, and the max is 960.

```{r}
ggplot(data = COD, mapping = aes(x = Damage))+
  geom_histogram(color = "black", fill = "blue")
```

Based on the visualization we can learn from the distribution of Damage. Based on the histogram, in most instances Damage was between 250 and 500 per game.

### FullPartial - Ayla Orona

```{r}
sum(is.na(COD$FullPartial))
```

There is not missing data for the FullPartial column in the data set.

```{r}
COD %>%
  group_by(FullPartial)%>%
  summarise(N=n())
  
```

Based on the summary statistics of the FullPartial column, we can determine that 191 instances were Full and 20 were partial.

```{r}
#full or partial based on eliminations
ggplot(data = COD, mapping = aes(x = FullPartial, y = Eliminations))+
  geom_boxplot()
```

Based on this visualization, we can see the differences in the amount of eliminations based on whether the game was full or partial. If the game was full, the elimination mean was 15, however, if it was partial, the mean was around 8. This could possibly due to the fact that because the player was playing a full game, their eliminations would increase because they had a longer amount of time of playing the game. 

### Game Type - Michael

```{r}
sum(is.na(COD$GameType))
```

```{r}
gt_table <- COD %>%
  group_by(GameType) %>%
  summarise(N = n()) %>%
  arrange(desc(N))

gt_table$GameType <- c("Team Death Match", "Hardpoint", "Domination", "Kill Confirmed")

gt_table %>%
  kable(
    digits = 2,
    format.args = list(big.mark = ","),
    caption = "Summary Table for Game Type",
    col.names = c("Map", "Total Games Played"),
    align = c("l", rep("c", 2)),
    booktabs = TRUE
  ) %>%
  kableExtra::kable_classic(lightable_options = "striped",
                            latex_options = c("scale_down", "HOLD_position"))
```

```{r}
gt_labs <- c("Domination", "Hardpoint", "Kill Confirmed", "Team Death Match")

ggplot(data = COD, mapping = aes(x = GameType, fill = GameType)) +
  geom_bar() + 
  labs(x = "Game Type", 
       y = "Games Played", 
       title = "Number of Games per Game Type",
       subtitle = "Call of Duty") +
  theme(
    plot.title = element_text(size = 16L,
                              face = "bold",
                              hjust = 0.5),
    plot.subtitle = element_text(size = 12L,
                                 hjust = 0.5),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    legend.position = "none") + 
    scale_x_discrete(labels= gt_labs)
```

I will do XPType and Map1


## 3. Exploring Result Column
```{r}
# Getting Wins, Losses, and Ties
COD <- COD %>%
  mutate(Win = ifelse(YourScore > OtherScore, 1, 0),
         Loss = ifelse(YourScore < OtherScore, 1, 0),
         Tie = ifelse(YourScore == OtherScore, 1, 0))

# Winning%
winRatio <- sum(COD$Win)/nrow(COD)
# Losing%
lossRatio <- sum(COD$Loss)/nrow(COD)
# Tie%
tieRatio <- sum(COD$Tie)/nrow(COD)
```

Win%: 0.4265403
Loss%: 0.5592417
Tie%: 0.01421801

Michael will write

